"use strict";(self.webpackChunkcrossmint_embedded_checkout=self.webpackChunkcrossmint_embedded_checkout||[]).push([[31373],{31373:(e,a,t)=>{t.d(a,{relayEngineTransaction:()=>d});var n=t(747),r=t(30260),s=t(3125),i=t(14217);const o=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],c=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function d(e){const{message:a,messageType:t,signature:i}=await async function({account:e,serializableTransaction:a,transaction:t,gasless:r}){const i=(0,n.P)({address:r.relayerForwarderAddress,chain:t.chain,client:t.client}),d=await(0,s.readContract)({contract:i,method:"function getNonce(address) view returns (uint256)",params:[e.address]}),[u,l]=await(async()=>{if(!a.to)throw new Error("engine transactions must have a 'to' address");if(!a.gas)throw new Error("engine transactions must have a 'gas' value");if(!a.data)throw new Error("engine transactions must have a 'data' value");if(r.experimentalChainlessSupport){const n={from:e.address,to:a.to,value:0n,gas:a.gas,nonce:d,data:a.data,chainid:BigInt(t.chain.id)};return[await e.signTypedData({domain:{name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:i.address},message:n,primaryType:"ForwardRequest",types:{ForwardRequest:c}}),n]}const n={from:e.address,to:a.to,value:0n,gas:a.gas,nonce:d,data:a.data};return[await e.signTypedData({domain:{name:r.domainName??"GSNv2 Forwarder",version:r.domainVersion??"0.0.1",chainId:t.chain.id,verifyingContract:i.address},message:n,primaryType:"ForwardRequest",types:{ForwardRequest:o}}),n]})();return{message:l,signature:u,messageType:"forward"}}(e),d=await fetch(e.gasless.relayerUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:(0,r.A)({request:a,type:t,signature:i,forwarderAddress:e.gasless.relayerForwarderAddress})});if(!d.ok)throw new Error(`Failed to send transaction: ${await d.text()}`);const l=await d.json();if(!l.result)throw new Error(`Relay transaction failed: ${l.message}`);const m=l.result.queueId,w=Date.now()+6e4;for(;Date.now()<w;){const a=await u({options:e,queueId:m});if(a)return{transactionHash:a.transactionHash,chain:e.transaction.chain,client:e.transaction.client};await new Promise((e=>setTimeout(e,1e3)))}throw new Error("Failed to find relayed transaction after 60000ms")}async function u(e){const{options:a,queueId:t}=e,n=a.gasless.relayerUrl.split("/relayer/")[0],r=await fetch(`${n}/transaction/status/${t}`,{method:"GET"}),s=await r.json();if(!r.ok)return null;const o=s.result;if(!o)return null;switch(o.status){case"errored":throw new Error(`Transaction errored with reason: ${o.errorMessage}`);case"cancelled":throw new Error("Transaction execution cancelled.");case"mined":return await(0,i.L)({client:a.transaction.client,chain:a.transaction.chain,transactionHash:o.transactionHash});default:return null}}}}]);