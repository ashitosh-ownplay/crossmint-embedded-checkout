"use strict";(self.webpackChunkcrossmint_embedded_checkout=self.webpackChunkcrossmint_embedded_checkout||[]).push([[32516],{32516:(e,a,t)=>{t.d(a,{relayOpenZeppelinTransaction:()=>c});var n=t(747),s=t(8908),r=t(30260),i=t(3125);const o=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],d=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function c(e){const{message:a,messageType:t,signature:c}=await async function({account:e,serializableTransaction:a,transaction:t,gasless:s}){const r=(0,n.P)({address:s.relayerForwarderAddress,chain:t.chain,client:t.client}),c=await(0,i.readContract)({contract:r,method:"function getNonce(address) view returns (uint256)",params:[e.address]}),[m,p]=await(async()=>{if(!a.to)throw new Error("OpenZeppelin transactions must have a 'to' address");if(!a.gas)throw new Error("OpenZeppelin transactions must have a 'gas' value");if(!a.data)throw new Error("OpenZeppelin transactions must have a 'data' value");if(s.experimentalChainlessSupport){const n={from:e.address,to:a.to,value:0n,gas:a.gas,nonce:c,data:a.data,chainid:BigInt(t.chain.id)};return[await e.signTypedData({domain:{name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:r.address},message:n,primaryType:"ForwardRequest",types:{ForwardRequest:d}}),n]}const n={from:e.address,to:a.to,value:0n,gas:a.gas,nonce:c,data:a.data};return[await e.signTypedData({domain:{name:s.domainName??"GSNv2 Forwarder",version:s.domainVersion??"0.0.1",chainId:t.chain.id,verifyingContract:r.address},message:n,primaryType:"ForwardRequest",types:{ForwardRequest:o}}),n]})();return{message:p,signature:m,messageType:"forward"}}(e),m=await fetch(e.gasless.relayerUrl,{method:"POST",body:(0,r.A)({request:a,type:t,signature:c,forwarderAddress:e.gasless.relayerForwarderAddress})});if(!m.ok)throw m.body?.cancel(),new Error(`Failed to send transaction: ${await m.text()}`);const p=await m.json();if(!p.result)throw new Error(`Relay transaction failed: ${p.message}`);const u=JSON.parse(p.result).txHash;if((0,s.q)(u))return{transactionHash:u,chain:e.transaction.chain,client:e.transaction.client};throw new Error(`Failed to send transaction: ${(0,r.A)(p)}`)}}}]);